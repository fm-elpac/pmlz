# 计划 pmlc-so

胖喵小云 object 存储

+ 适用于超小个人云: 1 ~ 10 台服务器硬件

+ **object 云存储能力**:
  极强的扩展能力, 支持多机多盘存储集群, 提供很大的总容量.
  系统性能随硬件的增加线性扩展, 很高的管理灵活度及容灾能力.

+ S3 兼容接口

+ 使用 rust (tokio) 编写,
  使用 PostgreSQL 存储元数据,
  使用 ostree 存储实际数据 (sha256).

+ 相比 `minio` 追求的企业级高性能, 高可用, 超大容量来说,
  pmlc-so 不需要太高的性能, 不需要很高的可用性, 不需要很大的容量.
  因为主要用于个人云, 这些情况都是显而易见的.

  pmlc-so 主要追求 **低成本** (**省电**, 支持廉价的老旧硬件),
  灵活配置 (**混合硬件部署**, **自动冷/热数据分区管理**, 方便扩容/缩容),
  容灾 (避免数据丢失).
  适合于几台老旧计算机 (PC) 组建一个超小个人云计算集群的场景.

相比 `minio` 提供以下功能特性:

+ **支持混合硬件部署**:
  一个集群中的每台服务器, 可以使用不同的硬件配置, 使用不同的存储器.

  比如不同的 CPU, 内存, 主板, 硬盘控制器, 操作系统等.

  同时混合使用 SSD / 机械硬盘, 同时使用不同容量的磁盘.

+ **基于测量 (bench mark) 的性能管理策略**:
  管理系统 "知道" 底层硬件的具体性能, 根据硬件能力分配任务 (能者多劳).

+ **低成本 (省电)**: 对穷人友好, 适合使用大容量磁盘存储冷数据.

  **自动冷/热数据分区管理**, 由于大部分数据都是冷数据,
  大部分硬盘被分配只存储冷数据, 从而可以长期休眠 (停转), 节省大量电费.

+ 非常方便的扩容/缩容, 增减集群中的机器及硬盘.

注: 为了照顾单身狗防止其 emo,
在所有相关文档中不得使用 "对象" 这个词 (除了此处),
全部使用 "object" 代替.

+ 主要协议: HTTP(S) GET/POST (tokio), JSON


## 分片存储

pmlc-so 对于 object 的元数据使用 PostgreSQL 数据库存储,
对于 object 实际数据 (内容数据) 使用其直接 `sha256` 的值进行标识.

从而实现自动去重 (dedup, 重复数据合并): 对于相同 `sha256` 的数据,
pmlc-so 确保每个存储器 (每块硬盘) 最多存储一份.

pmlc-so 集群由多台机器 (节点) 组成,
pmlc-so 并不存储每个 object 的数据位于哪个节点,
而是使用 **分片** 管理的方式 (类似 Openstack Swift).

object 数据根据其 `sha256` 前缀来进行分片, 支持以下 `分片配置`:

+ 前缀长度 2 (最小): 256 分片
+ 前缀长度 3 (推荐, 默认): 4096 分片
+ 前缀长度 4: 6_5536 分片
+ 前缀长度 5: 104_8576 分片

pmlc-so 存储每个分片的具体位置 (位于哪台机器, 哪块硬盘).
当访问一个 object 时, 首先从元数据获取其 `sha256` 值,
根据 `sha256` 前缀确定属于哪个分片,
查询这个分片位于哪台机器的哪块硬盘 (分片位置数据常驻内存),
最后进行访问.

在管理灵活度方面, 可以精确指定某个分片存储在某个机器的某块硬盘,
也就是可以移动一个分片的具体存储位置.
在性能方面, 由于分片数量较少且固定, 即使 object 有很多,
在查询 object 的具体存储位置 (分片存储位置) 时的性能也不会下降.

对于一个运行中的 pmlc-so 集群修改其 `分片配置` (sha256 前缀长度)
是可行的.
如果增加前缀长度, 采用 "原位配置" (新分片和老分片存储位置相同) 时,
集群的重新配置能够快速完成, 不需要大量移动数据.
配置变更完成后, 可以进行新分片的移动等管理操作.
但是如果缩短前缀长度, 基本上会导致所有数据重新分布,
需要大量数据的移动操作, 需要较长时间才能完成.


## 本地存储区 (SODR)

要求每个存储器 (每块硬盘) 上, 最多只能有一个存储区 (挂载目录).

底层文件系统: 建议使用 btrfs (不启用压缩).

SODR 目录结构:

+ `SODR/pmlc-so-ostree/`

  ostree user 仓库, 存储实际数据.

+ `SODR/pmlc-so.db`

  sqlite 数据库, 存储少量, 不经常变化的元数据, 启动时加载并常驻内存.

  比如 pmlc-so 版本号, 集群信息, 机器编号, 硬盘编号, 存储策略,
  分片数据 等.


## 集群管理

一个 pmlc-so 集群由多台机器 (节点) 组成, 一台机器只能属于一个集群.
每台机器具有多个存储器 (硬盘), 每个存储器只能属于一台机器.

每个节点都是对等的, 不区分主从/主备节点 (类似 Openstack Swift).

1. 指定机器: 集群由哪些节点组成 (创建集群).

2. 指定存储器 (硬盘): 每台机器有哪些硬盘用来存储数据.

   创建 SODR, 指定可用容量.

3. 创建 `存储策略` (全局管理).

4. 创建用户, 配置 `用户权限`.

5. 用户: 创建存储桶 (bucket) 并读/写 object.


## 存储策略

pmlc-so 的存储策略采用全局管理, 由系统管理员创建.
普通用户创建存储桶 (bucket) 时, 指定使用某个存储策略.

不同存储策略的分片分别进行管理.

+ 总存储份数 (备份策略):
  1 (允许丢失的数据), 2 (一般重要的数据), 3 (特别重要的数据), 4

+ 冷/热数据策略 (TODO)

+ (存储位置策略) 允许数据存储在哪些机器的哪些硬盘中.

+ 优先级 1: 抢占优先级

+ 优先级 2: 比例优先级


## 自动冷热数据管理

在一台机器的内部进行, 硬盘分为 `冷硬盘` 和 `热硬盘`.
要求所有机器始终在线 (一台机器不能休眠),
但是冷硬盘在无数据读写时可以休眠 (停止旋转).

TODO: SSD 是否不需要省电管理 ?

自动冷/热数据管理策略 (举栗):

+ 最大省电策略: 目标是, 所有硬盘, 尽可能多的硬盘被分配为冷硬盘,
  尽可能缩短总的冷硬盘旋转时间 (热硬盘始终旋转),
  尽可能减少冷硬盘的启动次数.


## 节点权限

相对于 PostgreSQL 数据库.

+ (基本) 读写 object 数据

+ 用户自助管理 (bucket 管理)

+ 全局管理
  (集群管理, 集群节点管理, 存储器管理, 存储策略管理, 用户管理)

+ 测量 (只读)


## 用户权限

+ 最大容量: 默认 100GB

  用户可存储的所有 object 的总大小.

+ 存储桶 (bucket) 最大数量: 默认 2000

  用户可创建的 bucket 个数.

+ object 最大数量: 默认 1M

  用户可存储的 object 个数.

+ 允许使用的存储策略 (名称列表)

  用户创建 bucket 时可以指定的存储策略.

+ 单个 object 最大字节: 默认 20GB

  单个 object 允许的最大大小.

+ 元数据最大字节: 默认 128KB

  单个 object 允许的最大元数据大小.

+ 最多同时上传: 默认 10

  可以同时上传 (写入尚未完成) 的 object 个数.

+ 最大上传缓冲区字节: 默认 20GB

  上传缓冲区 (写入尚未完成) 的最大大小.


## 存储桶权限

+ 是否开放访问: 无需用户认证即可读取 (只读)


## 客户端读取 object 流程

二阶段模式:

1. (阶段 1) 连接任意 pmlc-so 节点.

2. 发送用户名 (认证信息), bucket 名称, object 名称.

3. pmlc-so 进行用户认证, 查询元数据 (PostgreSQL), 如果出错返回错误信息.

4. pmlc-so 返回 `节点信息` (下一步要访问哪个节点),
   `票据` (ticket, 包括数据的 `sha256` 值, `存储策略名称`).

5. (阶段 2) 根据 `节点信息`, 连接相应的 pmlc-so 节点, 发送 `票据`.

6. pmlc-so 检查 `票据` 是否有效, 根据 `存储策略名称` 检查 `sha256`
   对应数据是否存在, 如果不存在返回错误信息,
   并在数据库 (PostgreSQL) 中记录这个错误.

7. pmlc-so 返回实际的数据.

代理模式:
由客户端首次连接的 pmlc-so 节点, 代替用户执行阶段 2, 用户不需要重新连接.

注: 二阶段模式 (GET) 可以通过 HTTP 302 重定向来实现,
从而对客户端基本透明 (无感).


## 客户端写入 object 流程

1. 连接任意 pmlc-so 节点.

2. 发送用户名 (认证信息), bucket 名称, object 名称, object 数据.

3. pmlc-so 进行用户认证, 查询 bucket 元数据 (PostgreSQL).
   等待 object 数据上传完毕.

4. pmlc-so 计算存储数据的 sha256 值, 写入元数据 (PostgreSQL).
   查找 sha256 (分片) 对应的存储节点, 向相应节点写入数据.

5. pmlc-so 清理临时文件, 报告写入完毕.

TODO
